<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Max-Pooling Demo</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0f172a;
    color: #e2e8f0;
    min-height: 100vh;
    padding: 1.5rem;
  }

  a { color: #818cf8; text-decoration: none; }
  a:hover { text-decoration: underline; }

  header { max-width: 1100px; margin: 0 auto 0.8rem; }
  header .back { font-size: 0.85rem; color: #94a3b8; }
  header .back:hover { color: #c4b5fd; }

  h1 {
    text-align: center;
    font-size: 1.6rem;
    font-weight: 700;
    margin-bottom: 0.3rem;
    color: #f8fafc;
  }

  .subtitle {
    text-align: center;
    color: #94a3b8;
    font-size: 0.95rem;
    margin-bottom: 1.5rem;
  }

  /* ---------- layout ---------- */
  .app {
    max-width: 1100px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
  }

  .top-row {
    display: flex;
    gap: 1.2rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .panel {
    background: #1e293b;
    border-radius: 12px;
    padding: 1rem 1.2rem;
    border: 1px solid #334155;
  }

  .panel h2 {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #94a3b8;
    margin-bottom: 0.7rem;
  }

  /* ---------- grids ---------- */
  .grid-wrap { display: flex; justify-content: center; }

  .grid {
    display: inline-grid;
    gap: 2px;
    user-select: none;
  }

  .cell {
    width: 46px;
    height: 46px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.82rem;
    font-weight: 600;
    border-radius: 4px;
    background: #334155;
    color: #e2e8f0;
    transition: background 0.15s, transform 0.15s, box-shadow 0.15s;
    position: relative;
  }

  /* input grid */
  #inputGrid .cell { cursor: pointer; }
  #inputGrid .cell.in-pool {
    background: #3b82f6;
    color: #fff;
    transform: scale(1.08);
    box-shadow: 0 0 8px rgba(59,130,246,0.5);
    z-index: 2;
  }
  #inputGrid .cell.is-max {
    background: #f59e0b;
    color: #1e293b;
    transform: scale(1.12);
    box-shadow: 0 0 12px rgba(245,158,11,0.6);
    z-index: 3;
  }

  /* output grid */
  #outputGrid .cell {
    font-size: 0.75rem;
    background: #1e293b;
    border: 1px solid #334155;
    color: #94a3b8;
  }
  #outputGrid .cell.active-output {
    background: #065f46;
    color: #6ee7b7;
    font-weight: 700;
    border-color: #10b981;
    transform: scale(1.08);
    box-shadow: 0 0 8px rgba(16,185,129,0.4);
    z-index: 2;
  }
  #outputGrid .cell.computed {
    color: #cbd5e1;
    background: #1e293b;
  }

  /* ---------- computation panel ---------- */
  .computation {
    display: flex;
    gap: 1.5rem;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
  }

  .comp-block { text-align: center; }

  .comp-block h3 {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #64748b;
    margin-bottom: 0.4rem;
  }

  .comp-grid {
    display: inline-grid;
    gap: 2px;
  }

  .comp-cell {
    width: 56px;
    height: 38px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.82rem;
    font-weight: 600;
    border-radius: 3px;
    background: #1e3a5f;
    color: #93c5fd;
  }

  .comp-cell.is-max {
    background: #f59e0b;
    color: #1e293b;
    font-weight: 800;
    box-shadow: 0 0 8px rgba(245,158,11,0.4);
  }

  .operator {
    font-size: 1.8rem;
    font-weight: 300;
    color: #475569;
  }

  .result-box { text-align: center; }

  .result-box .result-label {
    font-size: 0.7rem;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .result-box .result-value {
    font-size: 1.5rem;
    font-weight: 800;
    color: #10b981;
    margin-top: 0.15rem;
  }

  .breakdown {
    text-align: center;
    color: #94a3b8;
    font-size: 0.82rem;
    margin-top: 0.5rem;
    font-family: 'Courier New', monospace;
    min-height: 1.4em;
  }

  .hint {
    text-align: center;
    font-size: 0.8rem;
    color: #64748b;
    margin-top: 0.4rem;
  }

  /* ---------- controls ---------- */
  .controls {
    display: flex;
    gap: 0.6rem;
    flex-wrap: wrap;
    margin-bottom: 0.5rem;
    align-items: center;
  }

  .controls select {
    padding: 0.4rem 0.6rem;
    border-radius: 6px;
    border: 1px solid #475569;
    background: #1e293b;
    color: #e2e8f0;
    font-size: 0.8rem;
    cursor: pointer;
  }

  .param-row {
    display: flex;
    gap: 1.5rem;
    align-items: center;
    flex-wrap: wrap;
    margin-top: 0.5rem;
  }

  .param-row label {
    font-size: 0.82rem;
    color: #94a3b8;
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .param-row input[type="number"] {
    width: 50px;
    padding: 0.25rem 0.4rem;
    border-radius: 4px;
    border: 1px solid #475569;
    background: #0f172a;
    color: #e2e8f0;
    font-size: 0.82rem;
    text-align: center;
  }

  @media (max-width: 900px) {
    .top-row { flex-direction: column; align-items: center; }
    .computation { flex-direction: column; }
  }
</style>
</head>
<body>

<header>
  <a class="back" href="index.html">&larr; Back to Hub</a>
</header>

<h1>Interactive Max-Pooling Demo</h1>
<p class="subtitle">Hover over the input to slide the pooling window. The maximum value in each window becomes the output.</p>

<div class="app">

  <div class="top-row">

    <!-- Input -->
    <div class="panel">
      <h2>Input Feature Map</h2>
      <div class="controls">
        <label style="font-size:0.82rem;color:#94a3b8;">Preset:&nbsp;</label>
        <select id="imagePreset">
          <option value="gradient">Gradient</option>
          <option value="edges">Edges</option>
          <option value="checkerboard">Checkerboard</option>
          <option value="random">Random</option>
        </select>
      </div>
      <div class="grid-wrap"><div class="grid" id="inputGrid"></div></div>
    </div>

    <!-- Settings -->
    <div class="panel">
      <h2>Pooling Settings</h2>
      <div class="param-row">
        <label>Pool size:
          <select id="poolSizeSelect">
            <option value="2" selected>2 &times; 2</option>
            <option value="3">3 &times; 3</option>
            <option value="4">4 &times; 4</option>
          </select>
        </label>
      </div>
      <div class="param-row">
        <label>Stride: <input type="number" id="strideInput" value="2" min="1" max="4"></label>
      </div>
      <div class="hint" style="margin-top:0.8rem;text-align:left;">
        Max-pooling has no learned parameters.<br>
        It simply takes the maximum value<br>
        from each window position.
      </div>
    </div>

    <!-- Output -->
    <div class="panel">
      <h2>Pooled Output</h2>
      <div class="grid-wrap"><div class="grid" id="outputGrid"></div></div>
      <div class="hint" id="outputSize"></div>
    </div>
  </div>

  <!-- Computation breakdown -->
  <div class="panel">
    <h2>Computation at Current Position</h2>
    <div class="computation">
      <div class="comp-block">
        <h3>Pooling Window</h3>
        <div class="comp-grid" id="compWindow"></div>
      </div>
      <div class="operator">&rarr;</div>
      <div class="result-box">
        <div class="result-label">Max</div>
        <div class="result-value" id="compMax">&mdash;</div>
      </div>
    </div>
    <div class="breakdown" id="breakdownText"></div>
    <div class="hint">Each output cell = max of all values in the pooling window.</div>
  </div>

</div>

<script>
(() => {
  const IMG_SIZE = 8;
  let poolSize = 2;
  let stride = 2;
  let image = [];
  let hoverR = -1, hoverC = -1; // top-left of pool window

  // ---- image presets ----
  const imagePresets = {
    gradient() {
      const m = [];
      for (let r = 0; r < IMG_SIZE; r++) {
        const row = [];
        for (let c = 0; c < IMG_SIZE; c++)
          row.push(Math.round((r * IMG_SIZE + c) / (IMG_SIZE * IMG_SIZE - 1) * 255));
        m.push(row);
      }
      return m;
    },
    edges() {
      const m = [];
      for (let r = 0; r < IMG_SIZE; r++) {
        const row = [];
        for (let c = 0; c < IMG_SIZE; c++)
          row.push((r >= 2 && r <= 5 && c >= 2 && c <= 5) ? 200 : 50);
        m.push(row);
      }
      return m;
    },
    checkerboard() {
      const m = [];
      for (let r = 0; r < IMG_SIZE; r++) {
        const row = [];
        for (let c = 0; c < IMG_SIZE; c++)
          row.push(((r + c) % 2 === 0) ? 255 : 0);
        m.push(row);
      }
      return m;
    },
    random() {
      const m = [];
      for (let r = 0; r < IMG_SIZE; r++) {
        const row = [];
        for (let c = 0; c < IMG_SIZE; c++)
          row.push(Math.floor(Math.random() * 256));
        m.push(row);
      }
      return m;
    }
  };

  // ---- helpers ----
  function outSize() {
    return Math.floor((IMG_SIZE - poolSize) / stride) + 1;
  }

  function maxPoolAt(or, oc) {
    const startR = or * stride;
    const startC = oc * stride;
    let mx = -Infinity;
    for (let pr = 0; pr < poolSize; pr++)
      for (let pc = 0; pc < poolSize; pc++)
        mx = Math.max(mx, image[startR + pr][startC + pc]);
    return mx;
  }

  // ---- rendering ----
  function buildInputGrid() {
    const grid = document.getElementById('inputGrid');
    grid.innerHTML = '';
    grid.style.gridTemplateColumns = `repeat(${IMG_SIZE}, 46px)`;
    for (let r = 0; r < IMG_SIZE; r++) {
      for (let c = 0; c < IMG_SIZE; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.textContent = image[r][c];
        const v = image[r][c];
        cell.style.background = `rgb(${30 + v * 0.35}, ${40 + v * 0.35}, ${60 + v * 0.42})`;
        cell.addEventListener('mouseenter', () => onHover(r, c));
        grid.appendChild(cell);
      }
    }
  }

  function buildOutputGrid() {
    const os = outSize();
    const grid = document.getElementById('outputGrid');
    grid.innerHTML = '';
    if (os <= 0) {
      document.getElementById('outputSize').textContent = 'Pool too large for input';
      return;
    }
    grid.style.gridTemplateColumns = `repeat(${os}, 46px)`;
    for (let r = 0; r < os; r++) {
      for (let c = 0; c < os; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell computed';
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.textContent = maxPoolAt(r, c);
        grid.appendChild(cell);
      }
    }
    document.getElementById('outputSize').textContent = `${os} \u00d7 ${os} output`;
  }

  function highlightInput() {
    const cells = document.querySelectorAll('#inputGrid .cell');

    // find max in current window
    let maxVal = -Infinity;
    if (hoverR >= 0) {
      for (let pr = 0; pr < poolSize; pr++)
        for (let pc = 0; pc < poolSize; pc++)
          maxVal = Math.max(maxVal, image[hoverR + pr][hoverC + pc]);
    }

    cells.forEach(cell => {
      cell.classList.remove('in-pool', 'is-max');
      const r = parseInt(cell.dataset.r);
      const c = parseInt(cell.dataset.c);

      if (hoverR >= 0 &&
          r >= hoverR && r < hoverR + poolSize &&
          c >= hoverC && c < hoverC + poolSize) {
        cell.classList.add('in-pool');
        if (image[r][c] === maxVal && !document.querySelector('#inputGrid .cell.is-max')) {
          // highlight first occurrence of max
          cell.classList.add('is-max');
        }
      }

      if (!cell.classList.contains('in-pool')) {
        const v = image[r][c];
        cell.style.background = `rgb(${30 + v * 0.35}, ${40 + v * 0.35}, ${60 + v * 0.42})`;
      } else {
        cell.style.background = '';
      }
    });
  }

  function highlightOutput() {
    const outR = hoverR >= 0 ? hoverR / stride : -1;
    const outC = hoverC >= 0 ? hoverC / stride : -1;
    document.querySelectorAll('#outputGrid .cell').forEach(cell => {
      cell.classList.remove('active-output');
      if (parseInt(cell.dataset.r) === outR && parseInt(cell.dataset.c) === outC)
        cell.classList.add('active-output');
    });
  }

  function updateComputation() {
    const windowGrid = document.getElementById('compWindow');
    const maxEl = document.getElementById('compMax');
    const breakdownEl = document.getElementById('breakdownText');

    const cellW = poolSize <= 2 ? 56 : poolSize <= 3 ? 48 : 42;
    windowGrid.style.gridTemplateColumns = `repeat(${poolSize}, ${cellW}px)`;
    windowGrid.innerHTML = '';

    if (hoverR < 0) {
      maxEl.textContent = '\u2014';
      breakdownEl.textContent = '';
      for (let i = 0; i < poolSize * poolSize; i++)
        windowGrid.innerHTML += '<div class="comp-cell">\u2014</div>';
      return;
    }

    let mx = -Infinity;
    const values = [];
    for (let pr = 0; pr < poolSize; pr++)
      for (let pc = 0; pc < poolSize; pc++) {
        const v = image[hoverR + pr][hoverC + pc];
        values.push(v);
        mx = Math.max(mx, v);
      }

    let maxMarked = false;
    for (const v of values) {
      const cell = document.createElement('div');
      cell.className = 'comp-cell';
      cell.textContent = v;
      if (v === mx && !maxMarked) {
        cell.classList.add('is-max');
        maxMarked = true;
      }
      windowGrid.appendChild(cell);
    }

    maxEl.textContent = mx;
    breakdownEl.textContent = `max(${values.join(', ')}) = ${mx}`;
  }

  // ---- interaction ----
  function onHover(imgR, imgC) {
    // find nearest valid pool window top-left
    let topR = imgR - Math.floor(poolSize / 2);
    let topC = imgC - Math.floor(poolSize / 2);

    // snap to stride-aligned
    topR = Math.round(topR / stride) * stride;
    topC = Math.round(topC / stride) * stride;

    // clamp to last valid stride-aligned position
    const maxTop = Math.floor((IMG_SIZE - poolSize) / stride) * stride;
    topR = Math.max(0, Math.min(topR, maxTop));
    topC = Math.max(0, Math.min(topC, maxTop));

    if (topR === hoverR && topC === hoverC) return;
    hoverR = topR;
    hoverC = topC;
    highlightInput();
    highlightOutput();
    updateComputation();
  }

  function fullUpdate() {
    buildOutputGrid();
    highlightInput();
    highlightOutput();
    updateComputation();
  }

  // ---- controls ----
  document.getElementById('imagePreset').addEventListener('change', e => {
    image = imagePresets[e.target.value]();
    buildInputGrid();
    fullUpdate();
  });

  document.getElementById('poolSizeSelect').addEventListener('change', e => {
    poolSize = parseInt(e.target.value);
    hoverR = -1; hoverC = -1;
    fullUpdate();
  });

  document.getElementById('strideInput').addEventListener('change', e => {
    stride = Math.max(1, parseInt(e.target.value) || 1);
    hoverR = -1; hoverC = -1;
    fullUpdate();
  });

  document.getElementById('inputGrid').addEventListener('mouseleave', () => {
    hoverR = -1; hoverC = -1;
    highlightInput();
    highlightOutput();
    updateComputation();
  });

  // ---- init ----
  image = imagePresets.gradient();
  buildInputGrid();
  fullUpdate();
})();
</script>
</body>
</html>
